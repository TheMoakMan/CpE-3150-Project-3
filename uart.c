/***********************************************************************
MODULE:    UART
VERSION:   1.03
CONTAINS:  Routines for controlling the UART peripheral on the Philips
           P89LPC932
COPYRIGHT: Embedded Systems Academy, Inc. - www.esacademy.com
LICENSE:   May be freely used in commercial and non-commercial code
           without royalties provided this copyright notice remains
           in this file and unaltered
WARNING:   IF THIS FILE IS REGENERATED BY CODE ARCHITECT ANY CHANGES
           MADE WILL BE LOST. WHERE POSSIBLE USE ONLY CODE ARCHITECT
           TO CHANGE THE CONTENTS OF THIS FILE
GENERATED: On "Jun 24 2003" at "10:17:56" by Code Architect 2.01
***********************************************************************/

// SFR description needs to be included
#include <reg932.h>
#include "frequency.h"
#include "uart.h"

extern short * lengths;
extern NoteName ** octave_keys;
extern Note * song3;
extern Note ** songs;
// flag that indicates if the UART is busy transmitting or not
static bit mtxbusy;
extern void transmit(char * st);  

/***********************************************************************
DESC:    Initializes UART for mode 1
         Baudrate: 9600
         Uses Baud Rate Generator
RETURNS: Nothing
CAUTION: If interrupts are being used then EA must be set to 1
         after calling this function
************************************************************************/
void uart_init
  (
  void
  )
{
  unsigned int BRG_Val;
  // configure UART
  // clear SMOD0 to access SM0 (UART mode bit) in SCON
  PCON &= ~0x40;
  // Set to UART mode 1 and enable reception
  // Also clears the RI and TI flags
  SCON = 0x50;
  // clear SMOD1
  PCON &= 0x7f;
  // set SMOD1 (not used)
  // PCON |= (1 << 8);
  // Clear any status flags and set for a combine RI/TI interrupt
  SSTAT = 0x00;

  // enable break detect
  AUXR1 |= 0x40;

  // configure baud rate generator
  BRG_Val=(unsigned int)(OSC_FREQ/9600UL);
  BRG_Val=BRG_Val-16;
  BRGCON = 0x00;
  BRGR1 = BRG_Val>>8;
  BRGR0 = (unsigned char)(BRG_Val&0xff);
  BRGCON = 0x03;

  // TxD = push-pull, RxD = input
  P1M1 &= ~0x01;
  P1M2 |= 0x01;
  P1M1 |= 0x02;
  P1M2 &= ~0x02;

  // initially not busy
  mtxbusy = 0;

  // set isr priority to 0
  IP0 &= 0xEF;
  IP0H &= 0xEF;
  // enable uart interrupt
  ES = 1;

} // uart_init

/***********************************************************************
DESC:    UART Interrupt Service Routine
RETURNS: Nothing
CAUTION: uart_init must be called first
         EA must be set to 1
************************************************************************/
void uart_isr
  (
  void
  ) interrupt 4 using 1
{
  if (RI)
  {
		unsigned char input = uart_get();		
        Parse(input);
        

   // clear interrupt flag
    RI = 0;
	     //Parse(input);
  } // if

  if (TI)
  {
    // clear interrupt flag
    TI = 0;
    // no longer busy
    mtxbusy = 0;
  } // if

} // uart_isr

/***********************************************************************
DESC:    Transmits a 8-bit value via the UART in the current mode
         May result in a transmit interrupt if enabled.
RETURNS: Nothing
CAUTION: uart_init must be called first
************************************************************************/
void uart_transmit
  (
  unsigned char value    // data to transmit
  )
{
  while(mtxbusy);
  mtxbusy = 1;
  SBUF = value;
} // uart_transmit

/***********************************************************************
DESC:    Gets a received 8-bit value from the UART
RETURNS: Received data
CAUTION: uart_init must be called first
************************************************************************/
unsigned char uart_get
  (
  void
  )
{
  return SBUF;
} // uart_get

void Parse(char my_input)
{
  	if(my_input == 'C')
		{
			song3[0].name = C3;
			song3[0].value = Quarter;
			//song3[0].letter = 
			song3[1].name = D3;
			song3[1].value = Quarter;
			//song3[1].letter =
			song3[2].name = E3;
			song3[2].value = Quarter;
			//song3[2].letter =
			song3[3].name = F3;
			song3[3].value = Quarter;
			//song3[3].letter =
			song3[4].name = G3;
			song3[4].value = Quarter;
			//song3[4].letter =
			song3[5].name = A3;
			song3[5].value = Quarter;
			//song3[5].letter =
			song3[6].name = B3;
			song3[6].value = Quarter;
			//song3[6].letter =
			song3[7].name = C4;
			song3[7].value = Quarter;
			//song3[7].letter =
			songs[2] = song3;
			lengths[2] = 8;
		
		}
		else if(my_input == 'D')
		{
			song3[0].name = D3; 
			song3[0].value = Quarter;
			//song4[0].letter =
			song3[1].name = E3;
			song3[1].value = Quarter;
			//song4[1].letter =
			song3[2].name = Gb3;
			song3[2].value = Quarter;
			//song4[2].letter =
			song3[3].name = G3;
			song3[3].value = Quarter;
			//song4[3].letter =
			song3[4].name = A3;
			song3[4].value = Quarter;
			//song4[4].letter =
			song3[5].name = B3;
			song3[5].value = Quarter;
			//song4[5].letter =
			song3[6].name = Db4;
			song3[6].value = Quarter;
			//song4[6].letter =
			song3[7].name = D4;
			song3[7].value = Quarter;
			//song4[7].letter =
			songs[2] = song3;
			lengths[2] = 8;
		}
		else if(my_input == 'G')
		{
			song3[0].name = G3;
			song3[0].value = Quarter;
		//	song3[0].letter =
			song3[1].name = A3;
			song3[1].value = Quarter;
		//	song5[1].letter =
			song3[2].name = B3;
			song3[2].value = Quarter;
		//	song5[2].letter =
			song3[3].name = C4;
			song3[3].value = Quarter;
		//	song5[3].letter =
			song3[4].name = D4;
			song3[4].value = Quarter;
		//	song5[4].letter =
			song3[5].name = E4;
			song3[5].value = Quarter;
		//	song5[5].letter =
			song3[6].name = Gb4;
			song3[6].value = Quarter;
		//	song5[6].letter =
			song3[7].name = G4;
			song3[7].value = Quarter;
		//	song5[7].letter =
			songs[2] = song3;
			lengths[2] = 8;
		}
}





